{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Processes and Workflows","text":"<ol> <li> <p>Introduction to Agile Software Development:</p> <ul> <li>An overview of the Agile methodology, its principles, and its benefits in software development processes.</li> </ul> </li> <li> <p>The Software Development Lifecycle (SDLC):</p> <ul> <li>Detailed descriptions of different SDLC models, such as Waterfall, Scrum, and Kanban, and when to use each.</li> </ul> </li> <li> <p>Code Review Best Practices:</p> <ul> <li>Guidelines and tips for conducting effective code reviews, ensuring code quality, and promoting collaboration.</li> </ul> </li> <li> <p>Continuous Integration and Continuous Deployment (CI/CD):</p> <ul> <li>Explanation of CI/CD concepts and practices, including how to set up automated pipelines for code delivery.</li> </ul> </li> <li> <p>Agile Project Management with Scrum:</p> <ul> <li>An in-depth look at Scrum methodology, including sprint planning, backlog management, and daily stand-ups.</li> </ul> </li> <li> <p>DevOps Principles and Practices:</p> <ul> <li>An exploration of DevOps culture, tools, and practices that foster collaboration between development and operations teams.</li> </ul> </li> <li> <p>Release Management and Version Control:</p> <ul> <li>How to manage software releases, track changes using version control systems, and handle branching and merging strategies.</li> </ul> </li> <li> <p>Quality Assurance and Testing Workflows:</p> <ul> <li>A guide to designing test cases, test automation, and strategies for ensuring software quality.</li> </ul> </li> <li> <p>Bug Tracking and Issue Management:</p> <ul> <li>Best practices for tracking and resolving software defects and issues throughout the development process.</li> </ul> </li> <li> <p>Agile Metrics and Key Performance Indicators (KPIs):</p> <ul> <li>An explanation of the metrics and KPIs used to measure the success and progress of Agile projects, including velocity and burn-down charts.</li> </ul> </li> </ol>"},{"location":"agile-methodology/","title":"Agile methodology","text":""},{"location":"agile-methodology/#agile-methodology-implementation-in-the-engineering-team-workflow","title":"Agile Methodology Implementation in the Engineering Team Workflow","text":""},{"location":"agile-methodology/#introduction","title":"Introduction","text":"<p>Agile methodology is a dynamic and iterative approach to software development that emphasizes collaboration, adaptability, and delivering incremental value. In this document, we will explore how Agile is implemented in our engineering team's workflow and how it enhances our ability to create high-quality software efficiently.</p>"},{"location":"agile-methodology/#agile-principles-in-action","title":"Agile Principles in Action","text":"<p>Our engineering team embodies Agile principles in the following ways:</p> <ol> <li> <p>Customer Collaboration: We maintain a continuous and open line of communication with stakeholders, including product managers, designers, and end-users. Regular meetings, demos, and feedback sessions ensure that we are aligned with customer expectations.</p> </li> <li> <p>Cross-Functional Teams: Our teams are cross-functional, including developers, testers, and UX/UI designers. This structure allows for rapid decision-making and a holistic approach to problem-solving.</p> </li> <li> <p>Iterative Development: We break down our projects into smaller, manageable pieces, focusing on delivering working software in short iterations. This iterative approach allows us to adapt to changing requirements and make incremental improvements.</p> </li> <li> <p>Responding to Change: We understand that requirements can change, and we embrace this fact. Our flexible development process allows us to pivot quickly and accommodate evolving customer needs or market dynamics.</p> </li> </ol>"},{"location":"agile-methodology/#agile-workflow","title":"Agile Workflow","text":"<p>Our Agile workflow consists of the following key elements:</p> <ol> <li> <p>Backlog Grooming: We maintain a well-organized product backlog, which is continuously groomed to ensure that it contains well-defined user stories or tasks. The backlog is prioritized by business value and complexity.</p> </li> <li> <p>Sprint Planning: At the beginning of each sprint, we conduct sprint planning meetings to select a set of user stories from the backlog. These user stories become our sprint backlog.</p> </li> <li> <p>Daily Standups: Our teams hold daily stand-up meetings to ensure that everyone is aware of the current progress, challenges, and impediments. This fosters transparency and allows for quick issue resolution.</p> </li> <li> <p>Sprint Reviews: At the end of each sprint, we host sprint review meetings to demonstrate the completed work to stakeholders. Feedback from these reviews informs our future work.</p> </li> <li> <p>Retrospectives: Once for several sprints, we conduct retrospectives to reflect on what went well and what could be improved. We use this feedback to enhance our processes continually.</p> </li> <li> <p>Continuous Integration and Testing: Our development process includes continuous integration and automated testing to ensure the quality and stability of the software.</p> </li> <li> <p>Frequent Deployments: We prioritize the release of small, frequent updates to production. This approach minimizes risk and allows us to respond rapidly to changing requirements.</p> </li> </ol>"},{"location":"BackEnd/","title":"Main for BackEnd","text":""},{"location":"BackEnd/NET/","title":"Main for .NET","text":""},{"location":"BackEnd/NestJS/","title":"Main for NestJS","text":""},{"location":"BackEnd/NestJS/LinkedIn%20login/","title":"1. LinkedIn login","text":"<p>1.Go to https://www.linkedin.com/developers/app and create a new app</p> <p></p> <p>2.Populate Create app page. Also you need to create a new LinkedIn Page for your company</p> <p></p> <p>3.Once app is created Verify it</p> <p></p> <p>4.Once your app is verified you need to go to Products page and select \u2018Sign In \u2026\u2019</p> <p></p> <p>5.Check that after you selected product these scopes appeared on Auth tab:</p> <p></p> <p>6.Specify redirect URLs:</p> <p></p> <p>7.When you have Scopes and Redirection setup you can make queries to  - https://www.linkedin.com/oauth/v2/accessToken - to get accessToken (urlGetAccessToken in the code below) - https://api.linkedin.com/v2/userinfo - to exchange accessToken for user email (urlGetUserInfo in the code below)</p> <pre><code>    try {\n            const parameters = {\n                grant_type: 'authorization_code',\n                code: linkedInPayload.code,\n                redirect_uri: urlRedirect,\n                client_id: clientId,\n                client_secret: clientSecret,\n            };\n\n            let response = await firstValueFrom(this.httpService.post(urlGetAccessToken, parameters, { headers: { 'content-type': 'application/x-www-form-urlencoded' } }));\n            response = await firstValueFrom(this.httpService.get(urlGetUserInfo, { headers: { Authorization: `Bearer ${response.data.access_token}` } }));\n            email = response.data.email;\n        } catch (e) {\n            this.logger.log(e.message);\n            throw new HttpException(\"Can't exchange access code\", HttpStatus.BAD_REQUEST);\n        }\n</code></pre> <p>*This video can be usefu if you have problems with app creation https://www.youtube.com/watch?v=dfof_ha0WGM But it is a little bit dated and once you get app scopes workflow can be different</p>"},{"location":"BackEnd/NestJS/OpenAI/","title":"2. OpenAI integration","text":"<ol> <li> <p>Sign up at https://platform.openai.com/ and login</p> </li> <li> <p>Create new API key</p> </li> </ol> <p></p> <ol> <li> <p>To use OpenAI in nodejs project install openai npm package     https://www.npmjs.com/package/openai</p> </li> <li> <p>Code example for a request to openai:</p> </li> </ol> <pre><code>constructor(private configService: ConfigService) {\n        const openAiConfiguration = new Configuration({ apiKey: configService.get('openAi').penAiApiKey });\n        this.openAiApi = new OpenAIApi(openAiConfiguration);\n    }\n</code></pre> <pre><code>async getGPTResponse(message: string): Promise&lt;string&gt; {\n    try {\n        const completion = await this.openAiApi.createChatCompletion({\n            model: 'gpt-4-1106-preview',\n            messages: [{ role: 'user', content: message }],\n            temperature: 0.6\n        });\n\n        if (!completion?.data?.choices || !completion.data.choices[0]) {\n            return `Sorry, can't analyse this page =(`;\n        }\n\n        this.logger.log('Analysis ended...');\n        return completion.data.choices[0].message.content;\n    } catch (error) {\n        this.logger.log('Analysis ended with an ERROR...');\n        this.logger.log(error);\n        return `Sorry, can't analyse this page =(`;\n    }\n}\n</code></pre>"},{"location":"BackEnd/NestJS/Sending%20emails/","title":"3. Send emails in NestJs with NodemailerTransport","text":"<ol> <li>Add email credentials to .env file</li> </ol> <pre><code>EMAIL_FROM = support@perfectsite.ai\nSMTP_HOST = email-smtp.us-east-1.amazonaws.com\nSMTP_PORT = 587\nSMTP_USER = UserName\nSMTP_PASSWORD = UserPassword\n</code></pre> <ol> <li>Create email config class</li> </ol> <pre><code>import { IsNumber, IsString } from \"class-validator\";\n\nexport interface EmailConfig {\n    from: string;\n    smtp_host: string;\n    smtp_port: number;\n    smtp_user: string;\n    smtp_password: string;\n}\n\nexport class EmailConfigValidator implements EmailConfig {\n    @IsString()\n    readonly from: string;\n\n    @IsString()\n    readonly smtp_host: string;\n\n    @IsNumber()\n    readonly smtp_port: number;\n\n    @IsString()\n    readonly smtp_user: string;\n\n    @IsString()\n    readonly smtp_password: string;\n}\n\nexport const getEmailConfig = (): EmailConfig =&gt; ({\n    from: process.env.EMAIL_FROM || 'support@perfectsite.ai',\n    smtp_host: process.env.SMTP_HOST || '',\n    smtp_port: +process.env.SMTP_PORT || 587,\n    smtp_user: process.env.SMTP_USER || '',\n    smtp_password: process.env.SMTP_PASSWORD || '',\n});\n</code></pre> <ol> <li>Create email service and configure NodemailerTransport with     credentials from email config service</li> </ol> <pre><code>import {Injectable} from \\'@nestjs/common\\';\nimport {createTransport} from \\'nodemailer\\';\nimport \\* as Mail from \\'nodemailer/lib/mailer\\';\nimport {ConfigService} from \\'@nestjs/config\\';\n\n@Injectable()\nexport default class EmailService {\n    private nodemailerTransport: Mail;\n\n    constructor(private readonly configService: ConfigService) {\n        const {smtp_host, smtp_port, smtp_user, smtp_password} =\n        configService.get(\\'email\\');\n\n        this.nodemailerTransport = createTransport({\n        host: smtp_host,\n        port: smtp_port,\n        secure: false, // use TLS\n        auth: {\n            user: smtp_user,\n            pass: smtp_password,\n        },\n\n        tls: { ciphers: \\'SSLv3\\' }\n        });\n    }\n\n    sendMail(options: Mail.Options): Promise\\&lt;any\\&gt; {\n        return this.nodemailerTransport.sendMail(options);\n    }\n}\n</code></pre>"},{"location":"CMS/","title":"Main for CMS","text":""},{"location":"CMS/Drupal/","title":"Drupal","text":""},{"location":"CMS/Drupal/CustomDocksalCommands/","title":"3. Creating custom Docksal commands","text":"<p>Drupal development workflow often requires to move DB or <code>files</code> folder between environments, usually to our local.</p> <p>Now that we created our Drush aliases Let's set up custom Docksal commands to simplify this process.</p> <p>There are already some commands available in <code>.docksal/commands</code> folder after we completed Initial Drupal setup.md. These are simply shell scripts that can be executed using <code>fin command-name</code>, where <code>command-name</code> is the name of the file. For example: <code>fin pull-db</code>.</p> <p>Below are the most common commands:</p> <p>Pull DB from Dev to local (filename: <code>pull-db</code>): <pre><code>#!/usr/bin/env bash\nset -e\nset -x\n\nfin drush sql-sync @dev @local --structure-tables-list=\"cache*\" -y\nfin drush cim -y\nfin drush cr\n</code></pre></p> <p>Pull Files from Dev to local (filename: <code>pull-files</code>): <pre><code>#!/usr/bin/env bash\nset -e\nset -x\n\nfin drush rsync @dev:%files @local:%files -y\n</code></pre></p> <p>Push DB from local to Dev (filename: <code>push-db</code>): <pre><code>#!/usr/bin/env bash\nset -e\nset -x\n\nfin drush sql-sync @local @dev --structure-tables-list=\"cache*\" -y\nfin drush @dev cim -y\nfin drush @dev cr\n</code></pre></p> <p>Push Files from local to Dev (filename: <code>push-files</code>): <pre><code>#!/usr/bin/env bash\nset -e\nset -x\n\nfin drush rsync @local:%files @dev:%files -y\n</code></pre></p> <p>And so on and so forth.</p>"},{"location":"CMS/Drupal/CustomDocksalCommands/#additional-information-and-links","title":"Additional information and links:","text":"<ul> <li>Docksal custom commands https://docs.docksal.io/fin/custom-commands/</li> </ul>"},{"location":"CMS/Drupal/Initial%20Drupal%20setup/","title":"1. Initial Drupal setup using Docksal","text":""},{"location":"CMS/Drupal/Initial%20Drupal%20setup/#step-1-install-docksal","title":"Step 1: Install Docksal","text":"<p>Before you begin, make sure you have Docker installed on your machine. Once Docker is installed, you can proceed to install Docksal using the following commands:</p> <p><pre><code>curl -fsSL https://get.docksal.io | sh\n</code></pre> This command downloads and installs the Docksal CLI on your system. After installation, you should have access to the <code>fin</code> command, which is used to interact with Docksal.</p>"},{"location":"CMS/Drupal/Initial%20Drupal%20setup/#step-2-install-and-run-a-drupal-project","title":"Step 2: Install and run a Drupal Project","text":"<p>Now that Docksal is installed, let's create a new Drupal project. Navigate to the directory where you want to set up your project and run the following command:</p> <p><pre><code>fin project create\n</code></pre> Or use it's shorthand alias: <code>fin p create</code></p> <p>This command will launch a wizard in which you can select which type of CMS you need to install and run.</p> <p>It should look something like this: <pre><code>1. Name your project (lowercase alphanumeric, underscore, and hyphen): test-project\n\n2. What would you like to install?\n  PHP based\n    1.  Drupal 10 (Composer Version)\n    2.  Drupal 10 (BLT Version)\n    3.  Drupal 9 (Composer Version)\n    4.  Drupal 9 (BLT Version)\n    5.  Drupal 7\n    6.  Wordpress\n    7.  Magento\n    8. Laravel\n    9. Symfony Skeleton\n    10. Symfony WebApp\n    11. Grav CMS\n    12. Backdrop CMS\n\n  Go based\n    13. Hugo\n\n  JS based\n    14. Gatsby JS\n    15. Angular\n\n  HTML\n    16. Static HTML site\n\n  Custom\n    0. Custom git repository\n</code></pre></p> <p>This wizard will automatically download and build selected CMS into Docksal container. </p> <p>Installing Drupal 10 (Composer Version) should result in next output: <pre><code>[success] Installation complete.  User name: admin  User password: XXXXXXXXX\nOpen http://test-drupal-10.docksal in your browser to verify the setup.\nLook for admin login credentials in the output above.\n</code></pre></p>"},{"location":"CMS/Drupal/Initial%20Drupal%20setup/#step-3-install-and-run-a-drupal-project","title":"Step 3: Install and run a Drupal Project","text":"<p>Congratulations! Your new Drupal project is installed and ready for further work.</p> <p>To run / stop / restart project using Docksal <code>Fin</code> CLI tool navigate to project folder and use following commands:</p> <pre><code>fin p start \nfin p stop\nfin p restart\n</code></pre>"},{"location":"CMS/Drupal/Initial%20Drupal%20setup/#additional-information-and-links","title":"Additional information and links:","text":"<ul> <li>Docksal installation and documentation https://docksal.io</li> </ul>"},{"location":"CMS/Drupal/RemoteDrushExecutionOnAWS/","title":"2. Setting up Drush aliases to execute commands on remote AWS instances","text":"<p>Drush CLI tool is essential for Drupal development, thus it's very convenient to have ability execute its commands on remote instance. Thankfully Drush supports so-called aliases for this very purpose. Below is the guide how to set up aliases for AWS Bitnami environments and to use them with Docksal.</p>"},{"location":"CMS/Drupal/RemoteDrushExecutionOnAWS/#step-1-create-drush-configuration-file","title":"Step 1: Create drush configuration file","text":"<p>In the project root (alongside with <code>.docksal</code> and <code>composer.json</code>) create <code>drush/sites/self.site.yml</code> file.</p> <p>Configuration should look something like this:</p> <pre><code>local: # Alias for local environment, necessary for DB and Files download from remote\n  paths:\n    drush: /usr/local/bin\n    site: sites/default/\n    files: sites/default/files\n  root: /var/www/web\n  uri: 'http://project-name.docksal'\n\nqa: # Environment name\n  host: XXX.XXX.XXX.XXX # Environment SSH IP address\n  options:\n    command-specific:\n      sql-sync:\n        sanitize: true\n        no-ordered-dump: true\n        structure-tables:\n          common:\n            - cache\n            - cache_filter\n            - cache_menu\n            - cache_page\n            - history\n            - sessions\n            - watchdog\n      rsync:\n        mode: rlptzO\n        verbose: true\n        no-perms: true\n    source-command-specific:\n      sql-sync:\n        no-cache: true\n        structure-tables-key: common\n  paths:\n    dump-dir: /tmp\n    site: sites/default/\n    files: /bitnami/drupal/sites/default/files\n  root: /opt/bitnami/project-name/web\n  uri: 'https://qa.project-name.com/' # Environment URL\n  user: bitnami\n</code></pre>"},{"location":"CMS/Drupal/RemoteDrushExecutionOnAWS/#step-2-setting-up-remote-ssh-keys-for-drush","title":"Step 2: Setting up remote SSH keys for Drush","text":"<p>Drush executes commands using SSH, so in order for it to connect we need to tell Docksal to load additional keys into CLI container. To do that we need to create  <code>.docksal/docksal-local.env</code> file. </p> <p>In there we specify as many ssh key files as we need for any environment.  <pre><code>SECRET_SSH_KEY_DEV='private_ssh_key_file_for_dev'\nSECRET_SSH_KEY_QA='private_ssh_key_file_for_qa'\nSECRET_SSH_KEY_XXXX='private_ssh_key_file_for_xxxx'\n</code></pre> Format should be as follows <code>SECTER_SSH_KEY_XXXX</code> = <code>name_of_private_ssh_key_file</code> where XXXX is the server identifier.</p> <p>Private ssh key files should be copied to <code>~/.ssh</code> folder on local machine.  Docksal will automatically pull key files into CLI container so Drush can use them to connect to remote.</p> <p>Don't forget to restart Docksal containers using <code>fin p restart</code> command for changes to take effect.</p> <p>To use alias and execute Drush command on remote, use this format:</p> <p><code>fin drush @alias cache:rebuild</code> for cache rebuild operation. Where <code>@alias</code> is the environment name specified in <code>drush/sites/self.site.yml</code> described above.</p> <p>Examples:</p> <p><code>fin drush @qa cr</code> will run remote Drush on QA environment to rebuild Drupal cache.  <code>fin drush @dev ssh</code> will open remote SSH session on dev server.</p>"},{"location":"CMS/Drupal/RemoteDrushExecutionOnAWS/#additional-information-and-links","title":"Additional information and links:","text":"<ul> <li>Drush site aliases https://www.drush.org/12.x/site-aliases/</li> </ul>"},{"location":"DevOps/","title":"Main for DevOps","text":""},{"location":"DevOps/AWS/","title":"Main for AWS","text":""},{"location":"DevOps/AWS/SES%20no%20spam/","title":"1. Prevent project emails from getting into spam folder","text":""},{"location":"DevOps/AWS/SES%20no%20spam/#general-idea-is-to-send-emails-from-a-custom-domain-with-aws-ses-to-make-it-work-you-will-need-access-to-domain-registrar","title":"General idea is to send emails from a custom domain with AWS SES. To make it work you will need access to domain registrar.","text":"<ol> <li> <p>Go to AWS SES and create a new identity with identity type Domain</p> <p></p> <p></p> <p></p> </li> <li> <p>SES will provide several CNAME key-value records for verification. They should be added to domain DNS records in domain management console at a domain registrar site.</p> <p></p> </li> <li> <p>After successful verification it is possible to send mails from any email box under @some-domain.com (support@some-domain.com, admin@some-domain.com, etc.)</p> <p>But only in AWS SES Sandbox mode. Sandbox mode has two main limitations:</p> <ul> <li>Both sender and receiver emails should be verified</li> <li>Less than 200 mails per day can be sent</li> </ul> <p></p> </li> <li> <p>To get out of SES Sandbox (if you need) you can request a production     access:</p> <ul> <li>Go to Request Production access page</li> <li>Select mail type Transactional</li> <li> <p>As a description add a message like the following:</p> <p>We are an IT consulting company. You can verify that we have multiple accounts in AWS and we do not send spam. Currently we are working on a new project so we need SES for Transactional mails. It is still in the beta stage but we need to send emails to different users and we can't verify them all as a recepients. This is the main reason why we need to get out the sandbox. <p>Some information based on previous applications experience:</p> <p>1.Currently we are not going to send more than 100 mails per day</p> <p>2.We keep our recipient lists in RDS</p> <p>3.We do not manage bounces, complaints, and unsubscribe requests at the current moment. But we are not sending any marketing information. Also  we are going to create a specific email with a contact person to handle all complaints once we go to production</p> <p></p> <p></p> <p></p>"},{"location":"DevOps/Azure/","title":"Main for Azure","text":""},{"location":"DevOps/CLI/","title":"Main for CLI","text":""},{"location":"DevOps/General/","title":"Main for General","text":""},{"location":"DevOps/General/DBSchema/","title":"1. Create database schema visualization","text":"<p>1.Download DBSchema app for your platform</p> <p></p> <p>2.Install DBSchema</p> <p>3.Connect to a database</p> <p></p> <p></p> <p>4.Specify tables for a schema creation</p> <p></p> <p>5.Export in necessary format</p> <p></p>"},{"location":"DevOps/GitHub/","title":"Main for GitHub","text":""},{"location":"DevOps/GitLab/","title":"Main for GitLab","text":""},{"location":"DevOps/Kubernetes/","title":"Main for Kubernetes","text":""},{"location":"DevOps/Terraform/","title":"Main for Terraform","text":""},{"location":"FrontEnd/","title":"Main for FrontEnd","text":""},{"location":"FrontEnd/Angular/","title":"Main for Angular","text":""},{"location":"FrontEnd/Figma/","title":"Figma tokens","text":""},{"location":"FrontEnd/Figma/FigmaTokensGithubIntegration/","title":"2. How to connect Figma with GitHub repository to synchronize Design Tokens","text":"<p>Sign up at https://github.com/ and login.</p> <p>Got to <code>Settings &gt; tokens</code> page https://github.com/settings/tokens.</p> <p>Click on <code>Generate new token</code>.</p> <p></p> <p>On a New personal access token (classic) page fill in <code>Note</code> input with the description of the token, select <code>\u00c8xpiration</code> with <code>No Expiration</code> value and check <code>repo</code> under <code>Select scopes</code> section.</p> <p></p> <p>Copy generated GitHub access token.</p> <p>Go to Figma project and open Tokens Studio for Figma plugin</p> <p></p> <p>Switch to <code>Settings</code> tab and click on <code>Add new sync provider</code></p> <p></p> <p>Select <code>GitHub</code> option</p> <p></p> <p>Enter <code>Name</code> of the sync provider connection. </p> <p>Paste <code>Personal Access Token</code> generated in GitHub.</p> <p>Enter <code>Repository (owner/repo)</code> value <code>Door3Dev/cnhi-dls</code>. </p> <p>Select Git repo <code>Branch</code> where all changes for the Figma tokens are going to be pushed and pulled from - <code>figma-design-tokens</code>. </p> <p>Enter <code>File path</code> where figma tokens are located inside Git repository - <code>/tokens/figma/tokens.json</code>. </p> <p>And click <code>Save</code> button.</p> <p></p> <p>Now you should see at the bottom of the Tokens Studio for Figma plugin window a new set of items - GitHub branch name (<code>figma-design-tokens</code>) and two icons - to pull changes from GitHub and to push changes from Figma to GitHub.</p> <p></p> <p>Once you are done with the local changes to the Design tokens in Figma, you can click on <code>Push</code> icon highlighted with blue dot. </p> <p>New modal <code>Push to GitHub</code> will be opened, where you can enter <code>Commit message</code> and click <code>Push changes</code>.</p> <p></p> <p>To notify developers you have to <code>Create Pull Request</code>. Click on the button in new window, and you will be redirected to the GitHub site.</p> <p></p> <p>On an Open Pull Request page enter <code>Title</code>, select <code>Reviewers</code> and click on <code>Create pull request</code> button.</p> <p></p> <p>Congratulations! Integration are done!</p>"},{"location":"FrontEnd/React/","title":"Main for React","text":""},{"location":"home/agile-methodology/","title":"Agile methodology","text":""},{"location":"home/agile-methodology/#agile-methodology-implementation-in-the-engineering-team-workflow","title":"Agile Methodology Implementation in the Engineering Team Workflow","text":""},{"location":"home/agile-methodology/#introduction","title":"Introduction","text":"<p>Agile methodology is a dynamic and iterative approach to software development that emphasizes collaboration, adaptability, and delivering incremental value. In this document, we will explore how Agile is implemented in our engineering team's workflow and how it enhances our ability to create high-quality software efficiently.</p>"},{"location":"home/agile-methodology/#agile-principles-in-action","title":"Agile Principles in Action","text":"<p>Our engineering team embodies Agile principles in the following ways:</p> <ol> <li> <p>Customer Collaboration: We maintain a continuous and open line of communication with stakeholders, including product managers, designers, and end-users. Regular meetings, demos, and feedback sessions ensure that we are aligned with customer expectations.</p> </li> <li> <p>Cross-Functional Teams: Our teams are cross-functional, including developers, testers, and UX/UI designers. This structure allows for rapid decision-making and a holistic approach to problem-solving.</p> </li> <li> <p>Iterative Development: We break down our projects into smaller, manageable pieces, focusing on delivering working software in short iterations. This iterative approach allows us to adapt to changing requirements and make incremental improvements.</p> </li> <li> <p>Responding to Change: We understand that requirements can change, and we embrace this fact. Our flexible development process allows us to pivot quickly and accommodate evolving customer needs or market dynamics.</p> </li> </ol>"},{"location":"home/agile-methodology/#agile-workflow","title":"Agile Workflow","text":"<p>Our Agile workflow consists of the following key elements:</p> <ol> <li> <p>Backlog Grooming: We maintain a well-organized product backlog, which is continuously groomed to ensure that it contains well-defined user stories or tasks. The backlog is prioritized by business value and complexity.</p> </li> <li> <p>Sprint Planning: At the beginning of each sprint, we conduct sprint planning meetings to select a set of user stories from the backlog. These user stories become our sprint backlog.</p> </li> <li> <p>Daily Standups: Our teams hold daily stand-up meetings to ensure that everyone is aware of the current progress, challenges, and impediments. This fosters transparency and allows for quick issue resolution.</p> </li> <li> <p>Sprint Reviews: At the end of each sprint, we host sprint review meetings to demonstrate the completed work to stakeholders. Feedback from these reviews informs our future work.</p> </li> <li> <p>Retrospectives: Once for several sprints, we conduct retrospectives to reflect on what went well and what could be improved. We use this feedback to enhance our processes continually.</p> </li> <li> <p>Continuous Integration and Testing: Our development process includes continuous integration and automated testing to ensure the quality and stability of the software.</p> </li> <li> <p>Frequent Deployments: We prioritize the release of small, frequent updates to production. This approach minimizes risk and allows us to respond rapidly to changing requirements.</p> </li> </ol>"}]}